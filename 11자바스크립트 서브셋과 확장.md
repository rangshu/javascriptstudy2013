#11. 자바스크립트 서브셋과 확장


## 언어확장 ##
### 상수와 범위 변수 ###
#### 상수 ####
- 상수 선언 const 
- 유효범위는 var와 같고, 함수 최상단으로 끌어올려진다. (hoisted)
- 상수 선언 이후에 별도의 할당은 무시 한다.
- 상수를 재정의 하려하면, 에러를 발생시킨다.
- Javascript 1.5 이상에서 사용가능

```
const pi = 3.14; //상수정의
pi = 4; //무시
const pi = 4; //에러 발생.(상수 재정의)
var pi = 4; //에러 발생.(같은 이름 사용)
```

#### let ####
- 가장 가까운 블록 내에서, 그리고 중첩된 모든 하위 블록에서 유효하다.
- 우리가 평소에 쓰던 언어와 비슷한 유효범위
- 아직 표준은 아님
- Javascript 1.7 이상에서 가능.

```
function oddsums(n)
{
    let total = 0, result=[];
    for(let x = 1; x <= n; x++)
    {
        let odd = 2 * x - 1;
        total += odd;
        result.push(total);
    }
    console.log("total =", total);
    //console.log("add = ", add); //Error
    return result;
}

oddsums(5);
```
```
o = {x:1, y:2};
for(let p in o) console.log(p);
for each(let v in o) console.log(v);
console.log(p); //Error
console.log(v); //Error
```
```
let x = 1;
for(let x = x + 1; x < 5; x++)
    console.log(x);
{
   let x = x + 1; //x는 undefined 이기 때문에, x는 NaN이다.
   console.log(x); //NaN을 출력한다.
}
```
- let 블록구문, 변수와 초기화 표현식은 괄호안에 놓이고, 그다음 중괄호로 둘러싸인 블록구문이 따른다.

```
let x=1, y=2;
let (x=x+1, y=x+2)
{
    console.log(x+y); //print 5
};
console.log(x+y); //print 3
```
```
let x=1, y=2;
console.log(let (x=x+1, y=x+2) x+y); // print 5
console.log(x+y); // print 3
```

### 해체할당 ###
- 등호의 오른쪽에서 하나 이상의 값이 추출('해체')되어, 등호의 왼쪽에 지정된 변수로 저장된다.


```
//배열 사용
let [x,y] = [1,2]; // let x=1, y=2
[x,y] = [x+1, y+1]; // x=x+1, y=y+1
[x,y] = [y,x]; // chage value
console.log([x,y]); // print [3,2]
```
```
// [x,y] 좌표를 [r, theta] 극좌표로 변환.
function polar(x,y)
{
    return [Math.sqrt(x*x + y*y), Math.atan2(y,x)];
}

//극좌표를 데카르트 좌표계로 변환.
function cartesian(r, theta)
{
    return [r * Math.cos(theta), r * Math.sin(theta)];
}

let [r,theta] = polar(1.0, 1.0); // r = Math.sqrt(2), theta = Math.PI/4
let [x,y] = cartesian(r,theta); // x = 1.0, y= 1.0
```
- 양쪽의 배열 요소 개수가 일치할 필요 없음.
- 할당되지 못한 변수는 undefined로 설정.
- 오른쪽에 있는 추가값들은 무시된다.
- 특정 값을 건너뛰려면 쉼표로 건너뛴다.

```
let [x,y] = [1]; // x = 1, y = undefined;
[x,y] = [1,2,3]; //x = 1, y = 2;
[,x,,y] = [1,2,3,4] // x = 2, y = 4;
```

- 해체할당은 전체 데이터 구조를 값으로 사용한다.

```
let first, second, all;
all = [first, second] = [1,2,3,4]; // first = 1, second = 2, all = [1,2,3,4]
```

- 중첩 배열에서도 사용 가능하다.

``` 
let [one, [twoA, twoB]] = [1, [2,2.5], 3]; // one = 1, twoA = 2, twoB = 2.5
```

- 객체에서도 해체할당을 사용할 수 있다.

```
let transparent = {r:0.0, g:0.0, b:0.0, a:1.0};
let {r:red, g:green, b:blue} = transparent; //red = 0.0, green = 0.0, blue = 0.0

//let sin = Math.sin, cos = Math.cos, tan = Math.tan
let {sin: sin, cos: cos, tan: tan} = Math;
```

- 중첩객체에서도 사용할 수 있다.

```
let data = 
{
    name : "Javascript",
    type : "string",
    impl : [{engine: "spidermonkey", version: 1.7}, 
            {engine: "rhino", version: 1.7}]
};

let ({name: feature, impl: [{engine: impl1, version:v1}, {engine:impl2}]} = data)
{
    console.log(feature); // print Javascript
    console.log(impl1); // print spidermonkey
}
```

### 순회 ###
#### for/each loop ####
- Firefox 에서 지원.
- **프로퍼티의 값**들을 순회한다.
- 지금은 쓰이지 않음.
- https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for_each...in

```
let o = {one: 1, two: 2, three: 3};

for(let p in o) console.log(p); // print one, two, three
for each(let v in o) console.log(v); // print 1, 2, 3
```

- for/each 대신 for/of 가 나옴. (Ecmascript 6에서 지원할지도?)
- for/each or for/in은 배열의 요소와, 열거가능한 프로퍼티까지 나열한다.
- for/of는 배열의 요소만 나열한다.


```
let arr = [1,2,3];
arr.test = "hi";
console.log("=====for / in =====");
for(let i in arr)
{
    console.log(i);
}
console.log("=====for each / in =====");
for each(let i in arr)
{
    console.log(i);
}
console.log("=====for / of =====");
for (let i of arr)
{
    console.log(i);
}
```

#### iterator ####
- 컬렉션의 값들을 순회하고, 컬렉션에서 현재의 ***위치*** 를 추적하는데 필요한 모든 상태를 유지하는 객체.
- 반드시 next()메서드가 있어야 한다.
- next()를 호출하면, 컬렉션의 다음 값을 반환해야 한다.
- 더 순회할 값이 없을 때, next() 메서드에서 **StopIteration** 예외를 발생시켜야 한다.

```
function counter(start)
{
    let nextValue = Math.round(start);
    return {next : function() {return nextValue++; }};
}

let serialNumberGenerator = counter(1000);
let sn1 = serialNumberGenerator.next();
let sn2 = serialNumberGenerator.next();

console.log(sn1); // 1000 
console.log(sn2); // 1001
```
```
function rangeIter(first, last)
{
    let nextValue = Math.ceil(first);
    return {
        next:
        function()
        {
            if (nextValue > last) throw StopIteration;
            return nextValue++;
        }
    };
}

let r = rangeIter(1,5);
while(true)
{
    try
    {
        console.log(r.next());
    }
    catch(e)
    {
        if(e == StopIteration)
        {
            break;
        }
        else
        {
            throw e;
        }
    }
}

//try catch 문을 지우게 되면?
```
